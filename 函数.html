<!DOCTYPE html>
<html lang="zh">

	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta http-equiv="X-UA-Compatible" content="ie=edge" />
		<title>Document</title>
		<script src="js/jQuery.js" type="text/javascript" charset="utf-8"></script>
		<script type="text/javascript">
			window.load = function() {
				alert(1)
			}

			//			window.load(function () {
			//				alert(1)
			//			})

			$(function() {
				//alert(1)
			})
		</script>
	</head>

	<body>
		<script type="text/javascript">
			//函数表达式
			let Print = function(x) {
				console.log(x);
			};
			Print(1);
			//Window.onload  DOM.onclick ...
			//函数表达式 必不可少 当然jQuery除外

			//需要注意的是 函数表达式的右侧 是一个匿名函数   实名函数并不会起什么作用
			let Show = function S() {
				console.log('Show');
			};

			Show();
			//S();//ReferenceError

			//如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。
			S(); //SSS
			function S() {
				console.log('Jump');
			}

			function S() {
				console.log('SSS');
			}

			//另外上面的代码 还有一个问题 ：  后声明的却可以先使用？？？？
			//Answer:	JavaScript引擎将函数名视同变量名，
			//  所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。

			//不要 在条件语句中 声明函数

			//函数的属性和方法

			function Name(a, b, c, d) {
				console.log('Name');
			}

			//name属性
			console.log(Name.name);

			//length
			console.log(Name.length); //4 此时的length是指定义 多少个参数

			//toString方法
			console.log(Name.toString()); //函数的toString方法返回函数的源码。 包括 注释

			//函数的作用域

			//【No.1】
			let v = 1;

			function V() {
				let v = 2;
				console.log(v);
			}
			V(); //2
			console.log(v); //1

			//【No.2】
			let a = 1;

			let x = function() {
				console.log(a);
			};

			function G() {
				let a = 2;
				x();
			}
			G(); //1
			//函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。

			//【No.3】
			let Q = function() {
				console.log(c);
			};

			function Y(f) {
				let c = 2;
				f();
			}
			//Y(Q); //c is not defined
			//如果函数A调用函数B，函数B不会引用函数A的内部变量。要看函数B的自身的环境

			//【No.4】同样的，函数体内部声明的函数，作用域绑定函数体内部。
			function Ro() {
				var W = 1;

				function bar() {
					console.log(W);
				}
				return bar;
			}

			var W = 2;
			var f = Ro();
			f() // 1
			//函数Ro内部声明了一个函数bar，bar的作用域绑定Ro。当我们在Ro外部取出bar执行时，变量x指向的是Ro内部的x，而不是Ro外部的x。

			//传递方式
			//大致看了一眼 JS的传值方式和C#大致一样
			//值类型（原始值） 不会改变 			引用类型（object，函数）会改变

			//值类型 传递
			var p = 2;

			function f(p) {
				p = 3;
			}
			f(p);

			p // 2

			//引用类型传递
			var obj = {
				p: 1
			};
			function f(o) {
				o.p = 2;
			}
			f(obj);

			obj.p // 2
			
		</script>
	</body>

</html>