<!--
最骚的for循环
[1, 2, 3, 4].forEach(function(e) {
  var li = document.createElement("li");
  li.textContent = e;
  docfrag.appendChild(li);
});

直接把循环的值写成了一个数组 然后 forEach

对象的迭代循环 for...in
var obj = { a: 1, b: 2,c: 3 };

for(var prop in obj) {
	console.log("obj." + prop + " = " + obj[prop]);
}

// Output:
// "obj.a = 1"
// "obj.b = 2"
// "obj.c = 3"
		
-->
<!DOCTYPE html>
<html lang="zh">

	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta http-equiv="X-UA-Compatible" content="ie=edge" />
		<title>Document</title>
		<script type="text/javascript">
			window.onload = function() {
				var Em1 = document.querySelector("#d1 em:nth-child(1)").style;
				Em1.color = 'red';
				var Em_Array = document.querySelectorAll("#d1 em");

				//再次强调 一遍 此 x 是个索引！也可以当成 对象中的属性，效率低，不建议使用
				//				for(var x in Em_Array) {
				//					Em_Array[x].style.color = 'blue';
				//				};
				//

				//这个方法就好比是 C#中的 foreach  很喜欢！
				//				for(var x of Em_Array) {
				//					x.style.color = 'red';
				//					alert(x.style.color);
				//				};

				//Shit  谁说 lambda表达式 非要加 大括号了。。。
				//这个forEach方法 中有三个参数 ： 当前遍历对象 索引 数组本身,并且规定 这三个参数 全部添加
				Em_Array.forEach((Now, Index, Array) => {
					Now.style.color = 'yellow';
					console.log(Array.length);
					//					alert(Index);
				});

				var DG_Array = document.getElementById("d1").getElementsByTagName("em");

				var Now_EM = document.createElement('em');
				Now_EM.innerHTML = "This is No.6 EM";
				document.getElementById("d1").appendChild(Now_EM);

				//这就是差距。
				alert(Em_Array.length); //5
				alert(DG_Array.length); //6
			};
		</script>
	</head>

	<body>
		<div id="d1">
			<em>This is No.1 EM</em>
			<em>This is No.2 EM</em>
			<em>This is No.3 EM</em>
			<em>This is No.4 EM</em>
			<em>This is No.5 EM</em>
		</div>
	</body>

</html>