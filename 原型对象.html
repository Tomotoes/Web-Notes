<!DOCTYPE html>
<html lang="zh">

	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<meta http-equiv="X-UA-Compatible" content="ie=edge" />
		<title>Document</title>
	</head>

	<body>
		<script type="text/javascript">
			//引言
			//大部分面向对象的编程语言，都是以“类”（class）作为对象体系的语法基础。
			//JavaScript 语言不是如此，它的面向对象编程基于“原型对象”。

			//JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。
			//实例对象的属性和方法，可以定义在构造函数内部。

			//同一个构造函数的对象实例之间，无法共享属性。对系统资源的浪费

			//JavaScript 的每个对象都继承另一个对象，后者称为“原型”（prototype）对象。
			//只有null除外，它没有自己的原型对象。它就是 传说中站在顶峰的那个男人。

			//原型对象上的所有属性和方法， 都能被派生对象共享。 这就是 JavaScript 继承机制的基本设计。

			//通过构造函数生成实例对象时， 会自动为实例对象分配原型对象。
			//每一个构造函数都有一个prototype属性， 这个属性就是实例对象的原型对象。

			//只要修改原型对象，变动就立刻会体现在所有实例对象上。

			//如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。

			//如果一层层地上溯，所有对象的原型最终都可以上溯到Object.prototype，
			//即Object构造函数的prototype属性指向的那个对象。
			//那么，Object.prototype对象有没有它的原型呢？回答可以是有的，
			//就是没有任何属性和方法的null对象，而null对象没有自己的原型。

			//prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数。

			//instanceof运算符返回一个布尔值，表示指定对象是否为某个构造函数的实例。
			//由于instanceof对整个原型链上的对象都有效。

			//Object.getPrototypeOf方法返回一个对象的原型。这是获取原型对象的标准方法。

			//Object.setPrototypeOf方法可以为现有对象设置原型，返回一个新对象。
			//Object.setPrototypeOf方法接受两个参数， 第一个是现有对象， 第二个是原型对象。

			//Object.create方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。

			//对象实例的isPrototypeOf方法，用来判断一个对象是否是另一个对象的原型。

			//__proto__属性（前后各两个下划线）可以改写某个对象的原型对象。
			//根据语言标准，__proto__属性只有浏览器才需要部署，其他环境可以没有这个属性，
			//而且前后的两根下划线，表示它本质是一个内部属性，不应该对使用者暴露。
			//应该用Object.getPrototypeof()和Object.setPrototypeOf()，进行原型对象的读写操作。

			//因此，获取实例对象obj的原型对象，有三种方法。
			obj.__proto__
			obj.constructor.prototype
			Object.getPrototypeOf(obj)
			//最新的ES6标准规定，__proto__属性只有浏览器才需要部署，其他环境可以不部署。
			//而obj.constructor.prototype在手动改变原型对象时，可能会失效。
			//所以，推荐使用第三种Object.getPrototypeOf方法，获取原型对象。
		</script>
	</body>

</html>